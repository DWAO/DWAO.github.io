<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Centos7使用firewall替代iptable</title>
      <link href="/2019/11/28/Centos7%E4%BD%BF%E7%94%A8firewall%E6%9B%BF%E4%BB%A3iptable/"/>
      <url>/2019/11/28/Centos7%E4%BD%BF%E7%94%A8firewall%E6%9B%BF%E4%BB%A3iptable/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​        使用iptables 保存开放端口时，提示错误：<strong>The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.</strong></p><p>​        查阅资料发现：</p><p>​        Centos7.x 开始，开始使用systemd替代daemon服务，systemctl命令替代以往管理系统启动和服务的命令。</p><h2 id="改造步骤"><a href="#改造步骤" class="headerlink" title="改造步骤"></a>改造步骤</h2><ol><li><p>停止防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl stop firewalld</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl mask firewalld</span></span><br></pre></td></tr></table></figure></li><li><p>安装iptable-services</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install iptables-services</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>设置开机启动防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> iptables</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>重新保存开放端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> service iptables save</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl unmask firewalld.service</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>检查防火墙状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure></li></ol><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><ol><li><p>开启防火墙</p></li><li><p>查看端口开放状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp</span><br></pre></td></tr></table></figure></li><li><p>开放端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=123/tcp --permanent</span><br></pre></td></tr></table></figure></li><li><p>重载端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>查询端口是否开启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=123/tcp</span><br></pre></td></tr></table></figure></li><li><p>移除端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --remove-port=123/tcp</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心36问(二) Error 和Exception</title>
      <link href="/2019/11/27/Java%E6%A0%B8%E5%BF%8336%E9%97%AE-%E4%BA%8C-Error-%E5%92%8CException/"/>
      <url>/2019/11/27/Java%E6%A0%B8%E5%BF%8336%E9%97%AE-%E4%BA%8C-Error-%E5%92%8CException/</url>
      
        <content type="html"><![CDATA[<h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h4><p>Exception 和Error 都继承了Throwable 类。在Java 中只有Throwable 类型才能被抛出或者捕获。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><p>Exception：可预料的情况，可以被捕获，进行响应处理。主要分为可检查异常(checked)和不可检查异常(unchecked)。其中，可检查异常在源代码必须进行显式处理。不检查异常是所谓的运行时异常，如NPE 、ArrayOutOBoundException.</p></li><li><p>Error ： 正常情况下，一般不会发生的错误，并且大部分会导致程序处于非正常、不可恢复状态。</p></li></ul><h4 id="常见异常或错误"><a href="#常见异常或错误" class="headerlink" title="常见异常或错误"></a>常见异常或错误</h4><p><img src="D:%5Czzw%5Cbackup_blog%5Csource_posts%5Cimage-20191128231151174.png" alt="image-20191128231151174"></p><h4 id="NoClassDefFoundError-和ClassNotFoundException-的区别"><a href="#NoClassDefFoundError-和ClassNotFoundException-的区别" class="headerlink" title="NoClassDefFoundError 和ClassNotFoundException 的区别"></a>NoClassDefFoundError 和ClassNotFoundException 的区别</h4><ul><li><p>NoClassNotFoundException：发生在编译时期找不到类。</p></li><li><p>NoClassDefFoundError: JVM在编译时可以找到合适的类，而在运行时找不到合适的类引发的错误。</p><p>PS：</p><ol><li>可能引发NoClassDefFoundError的原因：</li></ol><ul><li>对应的class 在java 的classpath 中不可用；</li><li>对应类在运行jar 的mainFest文件中的classpath 属性中未定义；</li><li>程序的启动脚本覆盖了原来的classpath 变量；</li><li>NoClassDefoundException：是java.lang.LinkageError的子类，可能因为原生的类库不可用而导致。</li><li>检查日志是否由java.lang.ExceptionInitializerError的错误，若出现有可能由于静态初始化失败导致。</li><li>若存在多个不同的类加载器，也有可能导致错误出现。</li></ul></li></ul><ol start="2"><li>类加载器机制</li></ol><ul><li>委托。加载一个类的请求交给父类加载器，如果父类加载器不能找到或者加载这个类，那么再加载它。</li><li>可见性。子类的加载器可以看到父类加载器加载的类，而父类加载器看不到子类加载器加载的类。</li><li>单一性：仅加载一个类一次。</li></ul><h4 id="try-catch-resource"><a href="#try-catch-resource" class="headerlink" title="try-catch-resource"></a>try-catch-resource</h4><p>​    资源需要实现AutoCloseable 或者Closeable。</p><h4 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h4><ol><li>尽量避免捕获类似Exception的同样异常，而应该捕获特定异常。</li><li>不要生吞异常。</li><li>不要仅用e.printStackTrace, 不易排查问题， 应写入到日志系统中。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心36问(一) 怎么理解Java平台， Java是解释执行?</title>
      <link href="/2019/11/26/Java%E6%A0%B8%E5%BF%8336%E9%97%AE-%E4%B8%80-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3Java%E5%B9%B3%E5%8F%B0%EF%BC%8C-Java%E6%98%AF%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C/"/>
      <url>/2019/11/26/Java%E6%A0%B8%E5%BF%8336%E9%97%AE-%E4%B8%80-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3Java%E5%B9%B3%E5%8F%B0%EF%BC%8C-Java%E6%98%AF%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Java运行流程"><a href="#Java运行流程" class="headerlink" title="Java运行流程"></a>Java运行流程</h2><p>Java 运行过程如下：</p><p>源代码通过Javac编译生成字节码，字节码再由虚拟机内部的解释器将字节码转换为最终的机器码。</p><h2 id="Java-不都是解释运行"><a href="#Java-不都是解释运行" class="headerlink" title="Java 不都是解释运行"></a>Java 不都是解释运行</h2><p>大部分的JVM，比如常见的hotspot，提供了JIT（Just In Time）编译器，即动态编译器。主要在运行时将热点代码编译成机器码，这种情况下热点代码属于编译执行，不属于解释执行。</p><h2 id="Java-平台"><a href="#Java-平台" class="headerlink" title="Java 平台"></a>Java 平台</h2><img src="D:\zzw\backup_blog\img\Java平台.PNG" alt="Java平台"  /><h4 id="一次编译，处处运行"><a href="#一次编译，处处运行" class="headerlink" title="一次编译，处处运行"></a>一次编译，处处运行</h4><p>Java 编译生成的字节码，可以在任何包含JVM 环境的电脑上运行，即Java 相当于一个提供程序运行的平台，屏蔽了操作系统的底层，使开发者无需关注不同操作系统的差异性。</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>多态</li><li>封装</li><li>继承</li></ul><h4 id="JDK、JRE、JVM的区别"><a href="#JDK、JRE、JVM的区别" class="headerlink" title="JDK、JRE、JVM的区别"></a>JDK、JRE、JVM的区别</h4><ul><li>JVM： Java 虚拟机，将字节码解释运行为目的机器代码，跨平台的前提。</li><li>JRE： java 运行环境，包含JVM 和基础类库。</li><li>JDK： Jva 开发工具包，包括JVM+JRE+Java Tool。</li></ul><p>特色：</p><ul><li><p>没有指针，无需自己回收内存</p></li><li><p>泛型</p></li><li><p>JVM 基础概念和类加载机制</p></li><li><p>JDK 包含的工具</p></li></ul><h3 id="Java-编译执行浅谈"><a href="#Java-编译执行浅谈" class="headerlink" title="Java 编译执行浅谈"></a>Java 编译执行浅谈</h3><ul><li>Java 分配编译器和运行时</li><li>JVM 会通过类加载器加载字节码，解释或者编译执行。主流版本中采用解释和编译混合模式，即server模式的JVM 会进行上万次调用来手机信息进行高效的编译，client的上线是1500次。</li><li>-Xint： 告诉JVM 只进行解释执行，不对代码进行编译</li><li>-Xcomp：关闭解释器，禁止解释执行，又称最大优化级别。</li><li>AOT：将字节码直接编译成机器代码，形成静态的类库代码，可通过jaotc将模块编译成AOT库。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka or Zookeeper?</title>
      <link href="/2019/11/26/Eureka-or-Zookeeper/"/>
      <url>/2019/11/26/Eureka-or-Zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>​         Eureka本身是Netflix开源的一款提供服务注册和发现的产品，并且提供了相应的Java封装。在它的实现中，节点之间相互平等，部分注册中心的节点挂掉也不会对集群造成影响，即使集群只剩一个节点存活，也可以正常提供发现服务。哪怕是所有的服务注册节点都挂了，Eureka Clients（客户端）上也会缓存服务调用的信息。这就保证了我们微服务之间的互相调用足够健壮。 </p><pre><code>Spring Cloud Netflix在设计Eureka时遵守的就是AP原则。Eureka Server也可以运行多个实例来构建集群，解决单点问题，但不同于ZooKeeper的选举leader的过程，Eureka Server采用的是Peer to Peer对等通信。这是一种去中心化的架构，无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。</code></pre><p>​        如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。</p><p>​        一个新的Eureka Server节点启动后，会首先尝试从邻近节点获取所有实例注册表信息，完成初始化。Eureka Server通过getEurekaServiceUrls()方法获取所有的节点，并且会通过心跳续约的方式定期更新。默认配置下，如果Eureka Server在一定时间内没有接收到某个服务实例的心跳，Eureka Server将会注销该实例（默认为90秒，通过eureka.instance.lease-expiration-duration-in-seconds配置）。当Eureka Server节点在短时间内丢失过多的心跳时（比如发生了网络分区故障），那么这个节点就会进入自我保护模式。</p><p>​         什么是自我保护模式？默认配置下，如果Eureka Server每分钟收到心跳续约的数量低于一个阈值（instance的数量(60/每个instance的心跳间隔秒数)自我保护系数），并且持续15分钟，就会触发自我保护。在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳数重新恢复到阈值以上时，该Eureka Server节点就会自动退出自我保护模式。它的设计哲学前面提到过，那就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。该模式可以通过eureka.server.enable-self-preservation = false来禁用，同时eureka.instance.lease-renewal-interval-in-seconds可以用来更改心跳间隔，eureka.server.renewal-percent-threshold可以用来修改自我保护系数（默认0.85）。 </p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><pre><code>Zookeeper主要为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。曾经是Hadoop项目中的一个子项目，用来控制集群中的数据，目前已升级为独立的顶级项目。很多场景下也用它作为Service发现服务解决方案。 </code></pre><p>​        Zookeeper是基于CP来设计的，即任何时刻对Zookeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务请求的可用性。从实际情况来分析，在使用Zookeeper获取服务列表时，如果zookeeper正在选主，或者Zookeeper集群中半数以上机器不可用，那么将无法获得数据。所以说，Zookeeper不能保证服务可用性。</p><p>​        诚然，在大多数分布式环境中，尤其是涉及到数据存储的场景，数据一致性应该是首先被保证的，这也是zookeeper设计成CP的原因。但是对于服务发现场景来说，情况就不太一样了：针对同一个服务，即使注册中心的不同节点保存的服务提供者信息不尽相同，也并不会造成灾难性的后果。因为对于服务消费者来说，能消费才是最重要的——拿到可能不正确的服务实例信息后尝试消费一下，也好过因为无法获取实例信息而不去消费。（尝试一下可以快速失败，之后可以更新配置并重试）所以，对于服务发现而言，可用性比数据一致性更加重要——AP胜过CP。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flowable</title>
      <link href="/2019/11/21/flowable/"/>
      <url>/2019/11/21/flowable/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><ul><li><strong>ACT_RE_*</strong> :  ‘RE’代表<code>repository</code>。带有这个前缀的表包含“静态”信息，例如流程定义与流程资源（图片、规则等） .</li><li><strong>ACT_RU_*</strong>: ‘RU’代表<code>runtime</code>。这些表存储运行时信息，例如流程实例（process instance）、用户任务（user task）、变量（variable）、作业（job）等。 </li><li><strong>ACT_HI_*</strong>: ‘HI’代表<code>history</code>。这些表存储历史数据，例如已完成的流程实例、变量、任务等。 </li><li><strong>ACT_GE_*</strong>: 通用数据。在多处使用。 </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> flowable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署Ant Design Pro</title>
      <link href="/2019/11/20/Docker%E9%83%A8%E7%BD%B2Ant-Design-Pro/"/>
      <url>/2019/11/20/Docker%E9%83%A8%E7%BD%B2Ant-Design-Pro/</url>
      
        <content type="html"><![CDATA[<h2 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h2><p>开发环境下的配置的反向代理在部署时，需要同步修改nginx.conf.</p><p>如 config.ts 配置的内容：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    <span class="string">'/api/uaa'</span>: &#123;  </span><br><span class="line">      target: <span class="string">'http://192.168.0.148:8766'</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      pathRewrite: &#123; <span class="string">'^/api/uaa'</span>: <span class="string">''</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'/api/message'</span>: &#123;</span><br><span class="line">      target: <span class="string">'http://192.168.0.148:8999'</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      pathRewrite: &#123; <span class="string">'^/api/message'</span>: <span class="string">''</span> &#125;,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>nginx 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location ^~/api/uaa/ &#123;</span><br><span class="line">       proxy_pass http://192.168.0.148:8766/;</span><br><span class="line">       proxy_set_header   X-Forwarded-Proto $scheme;</span><br><span class="line">       proxy_set_header   X-Real-IP         $remote_addr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   location ^~/api/message/ &#123;</span><br><span class="line">       proxy_pass http://192.168.0.148:8999/;</span><br><span class="line">       proxy_set_header   X-Forwarded-Proto $scheme;</span><br><span class="line">       proxy_set_header   X-Real-IP         $remote_addr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> npm run docker-hub:build</span></span><br></pre></td></tr></table></figure><p>若出现以下情况，说明docker 未配置证书，参考IDEA 一键式发布应用到Docker进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: SSL error: HTTPSConnectionPool(host=&apos;host.com&apos;, port=2376): Max retries exceeded with url: /v1.25/info (Caused by SSLError(SSLError(1, u&apos;[SSL: SSLV3_ALERT_HANDSHAKE_FAILURE] sslv3 alert handshake failure (_ssl.c:590)&apos;),))</span><br></pre></td></tr></table></figure><h2 id="打包完成，运行镜像"><a href="#打包完成，运行镜像" class="headerlink" title="打包完成，运行镜像"></a>打包完成，运行镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host --name paas-ui Ant-Design-Pro</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Ant Design Pro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 一键式发布应用到Docker</title>
      <link href="/2019/11/20/IDEA%20%E4%B8%80%E9%94%AE%E5%BC%8F%E5%8F%91%E5%B8%83%E5%BA%94%E7%94%A8%E5%88%B0Docker/"/>
      <url>/2019/11/20/IDEA%20%E4%B8%80%E9%94%AE%E5%BC%8F%E5%8F%91%E5%B8%83%E5%BA%94%E7%94%A8%E5%88%B0Docker/</url>
      
        <content type="html"><![CDATA[<h2 id="开启远程访问"><a href="#开启远程访问" class="headerlink" title="开启远程访问"></a>开启远程访问</h2><h3 id="浪子版（裸奔版）"><a href="#浪子版（裸奔版）" class="headerlink" title="浪子版（裸奔版）"></a>浪子版（裸奔版）</h3><ol><li><p>修改docker.service 中ExecStart内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vi /usr/lib/systemd/system/docker.service</span></span><br></pre></td></tr></table></figure><p>将ExecStart 的内容修改如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H</span><br><span class="line">unix://var/run/docker.sock</span><br></pre></td></tr></table></figure></li><li><p>重启docker 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl daemon-reload</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> service docker restart</span></span><br></pre></td></tr></table></figure></li><li><p>开放端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /sbin/iptables -I INPUT -p tcp --dport 2375 -j ACCEPT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables-save</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="绅士版-（CA）"><a href="#绅士版-（CA）" class="headerlink" title="绅士版 （CA）"></a>绅士版 （CA）</h3><h4 id="1-创建文件夹，保存CA"><a href="#1-创建文件夹，保存CA" class="headerlink" title="1. 创建文件夹，保存CA"></a>1. 创建文件夹，保存CA</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir /usr/<span class="built_in">local</span>/ca</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/ca</span></span><br></pre></td></tr></table></figure><h4 id="2-创建密码-根据提示输入两次密码"><a href="#2-创建密码-根据提示输入两次密码" class="headerlink" title="2. 创建密码,根据提示输入两次密码"></a>2. 创建密码,根据提示输入两次密码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl genrsa -aes256 -out ca-key.pem 4096</span></span><br></pre></td></tr></table></figure><h4 id="3-输入组织信息"><a href="#3-输入组织信息" class="headerlink" title="3. 输入组织信息"></a>3. 输入组织信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem</span></span><br></pre></td></tr></table></figure><h4 id="4-生成server-key-pem"><a href="#4-生成server-key-pem" class="headerlink" title="4. 生成server-key.pem"></a>4. 生成server-key.pem</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl genrsa -out server-key.pem 4096</span></span><br></pre></td></tr></table></figure><h4 id="5-替换域名或IP"><a href="#5-替换域名或IP" class="headerlink" title="5. 替换域名或IP"></a>5. 替换域名或IP</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl req -subj <span class="string">"/CN=<span class="variable">$HOST</span>"</span> -sha256 -new -key server-key.pem -out server.csr</span></span><br></pre></td></tr></table></figure><p>PS: 根据实际需求，将$HOST 修改为自己的域名或者IP。</p><h4 id="6-添加白名单"><a href="#6-添加白名单" class="headerlink" title="6. 添加白名单"></a>6. 添加白名单</h4><p>如果在5 配置是IP，执行命令1，反之执行命令2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> subjectAltName = IP:<span class="variable">$HOST</span>,IP:0.0.0.0 &gt;&gt; extfile.cnf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> subjectAltName = DNS:<span class="variable">$HOST</span>,IP:0.0.0.0 &gt;&gt; extfile.cnf</span></span><br></pre></td></tr></table></figure><h4 id="7-设置证书只做验证服务器身份"><a href="#7-设置证书只做验证服务器身份" class="headerlink" title="7. 设置证书只做验证服务器身份"></a>7. 设置证书只做验证服务器身份</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</span></span><br></pre></td></tr></table></figure><h4 id="8-生成数字证书-输入之前的密码"><a href="#8-生成数字证书-输入之前的密码" class="headerlink" title="8. 生成数字证书,输入之前的密码"></a>8. 生成数字证书,输入之前的密码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> server.csr -CA ca.pem -CAkey ca-key.pem \-CAcreateserial -out server-cert.pem -extfile extfile.cnf</span></span><br></pre></td></tr></table></figure><h4 id="9-生成客户端的key-pem"><a href="#9-生成客户端的key-pem" class="headerlink" title="9. 生成客户端的key.pem"></a>9. 生成客户端的key.pem</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl genrsa -out key.pem 4096</span></span><br></pre></td></tr></table></figure><h4 id="10-配置客户端证书"><a href="#10-配置客户端证书" class="headerlink" title="10. 配置客户端证书"></a>10. 配置客户端证书</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl req -subj <span class="string">'/CN=client'</span> -new -key key.pem -out client.csr</span></span><br></pre></td></tr></table></figure><h4 id="11-配置客户端密钥"><a href="#11-配置客户端密钥" class="headerlink" title="11. 配置客户端密钥"></a>11. 配置客户端密钥</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf</span></span><br></pre></td></tr></table></figure><h4 id="12-生成签名证书"><a href="#12-生成签名证书" class="headerlink" title="12. 生成签名证书"></a>12. 生成签名证书</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> client.csr -CA ca.pem -CAkey ca-key.pem \-CAcreateserial -out cert.pem -extfile extfile.cnf</span></span><br></pre></td></tr></table></figure><h4 id="13-删除不需要的文件"><a href="#13-删除不需要的文件" class="headerlink" title="13. 删除不需要的文件"></a>13. 删除不需要的文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rm -v client.csr server.csr</span></span><br></pre></td></tr></table></figure><h4 id="14-设置密钥和证书只读"><a href="#14-设置密钥和证书只读" class="headerlink" title="14. 设置密钥和证书只读"></a>14. 设置密钥和证书只读</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chmod -v 0400 ca-key.pem key.pem server-key.pem</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chmod -v 0444 ca.pem server-cert.pem cert.pem</span></span><br></pre></td></tr></table></figure><h4 id="15-归集证书"><a href="#15-归集证书" class="headerlink" title="15. 归集证书"></a>15. 归集证书</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cp server-*.pem  /etc/docker/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp ca.pem /etc/docker/</span></span><br></pre></td></tr></table></figure><h4 id="16-修改Docker-配置，仅接收CA证书的客户端"><a href="#16-修改Docker-配置，仅接收CA证书的客户端" class="headerlink" title="16. 修改Docker 配置，仅接收CA证书的客户端"></a>16. 修改Docker 配置，仅接收CA证书的客户端</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /lib/systemd/system/docker.service</span></span><br></pre></td></tr></table></figure><p>将ExecStart 的内容修改如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/etc/docker/ca.pem --tlscert=/etc/docker/server-cert.pem --tlskey=/etc/docker/server-key.pem -H tcp://0.0.0.0:2376 -H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure><h4 id="17-重新启动Docker"><a href="#17-重新启动Docker" class="headerlink" title="17. 重新启动Docker"></a>17. 重新启动Docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl daemon-reload</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl restart docker</span></span><br></pre></td></tr></table></figure><h4 id="18-开放端口"><a href="#18-开放端口" class="headerlink" title="18. 开放端口"></a>18. 开放端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /sbin/iptables -I INPUT -p tcp --dport 2376 -j ACCEPT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables-save</span></span><br></pre></td></tr></table></figure><h2 id="IDEA-配置"><a href="#IDEA-配置" class="headerlink" title="IDEA 配置"></a>IDEA 配置</h2><ol><li><p>下载 docker integration   插件</p></li><li><p>添加Docker 配置</p><p><img src="D:%5Czzw%5Cblog%5Cimg%5Cdocker-setting.JPG" alt=""></p></li><li><p>POM配置，设置<packaging>jar</packaging>, 再执行maven:clean 生成jar</p></li><li><p>编写DcokerFile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> hub.c.<span class="number">163</span>.com/library/java:<span class="number">8</span>-jre</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> target/*.jar PaaSServer.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8761</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>, <span class="string">"-jar"</span>, <span class="string">"PaaSServer.jar"</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>配置Run Configuration</p><p><img src="D:%5Czzw%5Cblog%5Cimg%5Cdocker_run_configuration.png" alt="image-20191120144754107"></p></li><li><p>点击运行，可在下方看到部署过程</p><p><img src="D:%5Czzw%5Cblog%5Cimg%5Cdocker_container.png" alt="image-20191120144907185"></p></li></ol><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://blog.csdn.net/ChineseYoung/article/details/83107353#commentsedit" target="_blank" rel="noopener">在idea中一键部署项目到Docker及CA认证</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 安装与卸载</title>
      <link href="/2019/11/20/docker-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/"/>
      <url>/2019/11/20/docker-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>这是一个勤勤恳恳的搬砖工</p><a id="more"></a><h2 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h2><p>集装箱，一键式打包部署环境，一次生成，处处运行。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h4><ul><li>linux 内核至少在3.8 以上，建议3.10以上。</li></ul><p>PS： 查看内核版本命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><ul><li>升级yum 版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><ul><li>安装相关依赖</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><ul><li>设置yum 源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><ol><li>查看docker 版本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><ol start="2"><li><p>选择合适的版本,这里选择的是18.06.1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce-18.06.1.ce</span><br></pre></td></tr></table></figure></li><li><p>启动docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>设置docker 自启动 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>检查docker 安装是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure></li></ol><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ol><li><p>查看docker 安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep docker</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>删除安装的软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove docker-engine.x86_64</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>删除镜像、容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/qgc1995/p/9553572.html" target="_blank" rel="noopener">Centos7下安装Docker</a></p><p>[<a href="https://www.cnblogs.com/a1260700062/p/9923349.html" target="_blank" rel="noopener">CentOS7上Docker安装与卸载</a>]</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你建博客</title>
      <link href="/2019/11/20/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/11/20/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>热衷技术分享的人总想搭建自己的博客，此文章将手把手带你搭建属于自己的博客。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>安装Git</p></li><li><p>安装NodeJS</p></li><li><p>注册github 账号</p></li><li><p>设置国内镜像地址</p><p>依次执行以下两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm config set registry https://registry.npm.taobao.org</span><br><span class="line">$ npm info underscore</span><br></pre></td></tr></table></figure><p>配置成功，会在控制台显示对应的JSON信息。</p></li></ul><h2 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h2><h4 id="Hexo-初始化"><a href="#Hexo-初始化" class="headerlink" title="Hexo 初始化"></a>Hexo 初始化</h4><ol><li><p>创建文件夹，保存博客文档。</p></li><li><p>安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure></li><li><p>初始化hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure></li><li><p>生成界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure></li><li><p>启动服务,在浏览器打开控制台链接进行预览。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></li></ol><h4 id="github-配置"><a href="#github-配置" class="headerlink" title="github 配置"></a>github 配置</h4><ol><li><p>创建公共仓库【私有仓库会无法访问】，仓库名为 github账户名.github.io (如dwao.github.io)</p></li><li><p>修改博客文件夹目录下的_config.yml 的deploy信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &apos;git&apos;</span><br><span class="line">  repo: https://github.com/DWAO/DWAO.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li></ol><h4 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h4><ol><li><p>安装git的部署工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>依次执行以下两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hext g</span><br><span class="line">$ hext d</span><br></pre></td></tr></table></figure></li></ol><p>至此，你的博客搭建完成。稍等片刻，输入链接（地址为之间配置的仓库名,本例是dwao.github.io）.</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
